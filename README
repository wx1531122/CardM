1. 产品需求文档 (PRD) - 卡片档期管理工具 MVP
1.1. 文档版本
版本号
更新日期
更新人
更新内容
V1.0
2025年5月28日
YQ
初始MVP需求文档创建

1.2. 引言与概述
产品名称： 卡片管理工具
产品目标： 为用户提供一个简单、易用的Web应用程序，用于记录和管理个人卡片的出租档期，替代手动记忆，避免时间冲突，提高管理效率。
项目背景： 用户当前通过大脑记忆管理卡片的不同使用者和预订时间，过程繁琐且容易出错。此产品旨在解决这一痛点。
1.3. 产品目标
核心目标： 允许用户快速、准确地录入、查看和删除卡片预订信息。
易用性： 提供简洁直观的用户界面，降低学习成本。
可靠性： 确保预订数据被持久化存储，不易丢失。
1.4. 目标用户
主要用户： 产品所有者本人，即需要管理卡片出租档期的个人。
1.5. 用户故事
编号
角色
我想要...
以便我能...
优先级
US01
卡片管理者
能够快速录入一个新的预订信息，包括使用者、日期、开始和结束时间
及时记录下新的档期安排
高
US02
卡片管理者
能够清晰地查看到所有已预订的档期，并按时间顺序排列
方便地了解卡片在任意时间的占用情况
高
US03
卡片管理者
能够删除已录入的错误或已取消的预订
保持预订信息的准确性
高
US04
卡片管理者
（MVP简化）如果需要修改预订，我可以通过先删除再重新添加的方式完成
修正错误的预订信息（MVP阶段简化操作）
中
US05
卡片管理者
打开应用就能看到我的预订数据
不用担心数据丢失，随时可以查看
高

1.6. 功能性需求 (MVP)
FR01: 预订创建
FR01.1: 系统应提供一个表单，允许用户输入以下信息：
使用者标识 (文本)
预订日期 (日期选择)
开始时间 (时间选择)
结束时间 (时间选择)
FR01.2: 用户提交表单后，系统应将该预订信息保存到数据库。
FR01.3: 保存成功后，页面应刷新并显示最新的预订列表。
FR01.4: 系统应对输入进行基础的后端校验（如必填项）。
FR02: 预订展示
FR02.1: 系统应在主页面以列表形式展示所有已保存的预订信息。
FR02.2: 列表应至少包含以下信息：使用者标识、预订日期、开始时间、结束时间。
FR02.3: 预订列表应默认按预订日期（升序）和开始时间（升序）进行排序。
FR03: 预订删除
FR03.1: 系统应允许用户删除列表中的任意一条预订记录。
FR03.2: 用户确认删除后，该预订记录应从数据库中移除。
FR03.3: 删除成功后，页面应刷新并显示更新后的预订列表。
FR04: 数据持久化
FR04.1: 所有预订数据应被存储在SQLite数据库中，确保应用重启或关闭后数据不丢失。
1.7. 非功能性需求 (MVP)
NF01: 易用性：
界面简洁直观，操作流程符合用户习惯。
用户无需培训即可上手使用。
NF02: 性能：
页面加载和数据操作（增、删、查）响应迅速，满足单用户使用场景。
NF03: 可靠性：
数据存储可靠，不会轻易丢失。
NF04: 部署：
MVP阶段主要支持本地运行。
1.8. 衡量成功的标准 (MVP 对用户而言)
用户能够顺畅地完成预订的添加、查看和删除操作。
使用该工具后，用户管理卡片档期的效率显著提升，错误明显减少。
用户对产品的整体易用性和稳定性感到满意。
1.9. 未来考虑/暂不包含在MVP中的功能
完整的预订编辑功能（而非删除后重添）。
预订时间冲突检测与提醒。
日历视图展示。
用户认证机制。
数据导出功能。
多用户协作或只读分享。
云端部署与多设备同步。
2. 技术方案文档 - 卡片档期管理工具 MVP
2.1. 文档版本
版本号
更新日期
更新人
更新内容
V1.0
2025年5月28日
YQ
初始MVP技术方案文档创建

2.2. 引言与概述
本文档描述了“卡片档期管理工具”MVP的技术实现方案。该方案旨在以Python Flask框架为核心，结合SQLite数据库和HTML/CSS前端技术，快速构建一个满足核心需求的Web应用。
2.3. 系统架构
架构模式： 单体应用，客户端-服务器 (Client-Server) 架构。
客户端 (Client)： 用户浏览器，负责渲染HTML页面和用户交互。
服务器 (Server)： Flask应用，负责处理业务逻辑、数据存储和HTTP请求响应。
组件交互： 用户通过浏览器访问Flask应用 -> Flask处理请求，与SQLite数据库交互 -> Flask返回HTML页面给浏览器。
2.4. 技术栈选型
后端框架： Python 3.11 + Flask
理由： 轻量级，快速开发，Python生态丰富，满足MVP需求。
数据库： SQLite 3
理由： 文件型数据库，无需额外服务安装，配置简单，适合单用户或小型应用，集成于Python标准库。
前端技术：
HTML5
CSS3 + Bootstrap 5
JavaScript (ES6+) (可选，MVP阶段主要用于增强用户体验，非核心逻辑)
开发与运行环境：
标准Python开发环境 (pip, venv)
代码编辑器 (VS Code, PyCharm, etc.)
版本控制: Git
2.5. 数据模型/数据库设计
数据库文件： database/schedule.db (相对于项目根目录)
数据表： bookings
| 字段名 | 数据类型 | 约束条件 | 描述 |
| :------------- | :---------- | :--------------------------------- | :--------------- |
| id | INTEGER | PRIMARY KEY AUTOINCREMENT | 预订唯一标识 |
| renter_name | TEXT | NOT NULL | 使用者标识/名称 |
| booking_date | TEXT | NOT NULL | 预订日期 (YYYY-MM-DD) |
| start_time | TEXT | NOT NULL | 开始时间 (HH:MM) |
| end_time | TEXT | NOT NULL | 结束时间 (HH:MM) |
| created_at | TEXT | DEFAULT CURRENT_TIMESTAMP | 记录创建时间戳 |
数据库操作： 使用Python内置的 sqlite3 模块执行SQL语句。可以封装数据库操作函数在 models.py 或直接在 app.py 中。
2.6. 后端API设计 (Flask路由)
所有路由均返回渲染后的HTML页面或重定向。
GET /
描述： 显示主页面，包括预订表单和当前所有预订的列表。
逻辑：
从 bookings 表查询所有记录。
按 booking_date (ASC), start_time (ASC) 排序。
将查询结果传递给 index.html 模板进行渲染。
响应： HTML页面。
POST /add_booking
描述： 处理添加新预订的请求。
请求体 (Form Data)： renter_name, booking_date, start_time, end_time。
逻辑：
接收表单数据。
进行后端数据校验 (如必填项非空)。
将数据插入 bookings 表。
响应： 重定向到 GET /。
POST /delete_booking/<int:booking_id>
描述： 处理删除指定预订的请求。
URL参数： booking_id (预订的ID)。
逻辑：
根据 booking_id 从 bookings 表删除对应记录。
响应： 重定向到 GET /。
2.7. 前端设计概要
主页面 (templates/index.html):
使用Jinja2模板引擎。
结构：
一个用于添加新预订的HTML表单 (<form method="POST" action="{{ url_for('add_booking') }}">)。
输入字段对应 renter_name, booking_date (使用 <input type="date">), start_time (使用 <input type="time">), end_time (使用 <input type="time">)。
提交按钮。
一个HTML表格 (<table>) 用于展示预订列表。
表头：使用者、日期、开始时间、结束时间、操作。
使用Jinja2循环遍历后端传递的预订数据，渲染表格行。
每行包含一个“删除”按钮，该按钮通常是一个提交POST请求到 /delete_booking/<id> 的小表单或通过JavaScript辅助提交。
CSS框架：
通过CDN引入所选CSS框架 (如Bootstrap)。
使用框架提供的类来快速美化表单、表格、按钮等元素。
JavaScript (可选)：
可用于简单的前端表单校验，提升用户体验。
对于删除操作，可以使用JavaScript弹出确认对话框。
2.8. 项目结构建议



/card_scheduler_project
├── app.py                 # Flask主应用文件 (路由、核心逻辑)
├── models.py              # (可选，推荐) 数据库交互函数/模型
├── database/
│   └── schedule.db        # SQLite数据库文件
├── static/
│   ├── css/
│   │   └── (css框架文件)
│   └── js/
│       └── script.js      # (可选) 前端JS
├── templates/
│   └── index.html         # 主HTML模板
│   └── (base.html etc. if using template inheritance)
├── requirements.txt       # Python依赖 (Flask)
└── .gitignore


2.9. 部署策略 (MVP)
主要部署方式： 用docker容器的方式部署到ubuntu的云服务器上
2.10. 错误处理与日志
错误处理： Flask提供基本的错误页面。对于MVP，主要关注核心流程的顺畅，可使用Flask内置的错误处理机制。
日志： Flask内置的日志功能可用于开发调试。对于生产级别日志，MVP阶段可暂不深入配置。
2.11. 安全考虑 (MVP)
输入校验： 后端对用户输入进行基础的有效性和存在性校验。
SQL注入： 使用参数化查询（sqlite3 模块的 ? 占位符）来防止SQL注入。
XSS (跨站脚本)： Jinja2模板引擎默认对输出进行HTML转义，有助于防止XSS。
CSRF (跨站请求伪造)： 对于MVP阶段且为个人本地使用的应用，CSRF风险较低，可暂不实现CSRF保护。若部署到公网或有更高安全需求时应添加。
认证与授权： MVP阶段不包含用户认证。应用数据对运行该应用的本地用户可见。
